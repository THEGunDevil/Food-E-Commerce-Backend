package handlers

// import (
// 	"errors"
// 	"log"
// 	"math"
// 	"net/http"
// 	"strconv"
// 	"strings"
// 	"time"

// 	"github.com/THEGunDevil/Food-E-Commerce-Backend.git/internal/db"
// 	gen "github.com/THEGunDevil/GoForBackend/internal/db/gen"
// 	"github.com/THEGunDevil/GoForBackend/internal/models"
// 	"github.com/THEGunDevil/Food-E-Commerce-Backend.git/internal/services"
// 	"github.com/gin-gonic/gin"
// 	"github.com/google/uuid"
// 	"github.com/jackc/pgx/v5"
// 	"github.com/jackc/pgx/v5/pgtype"
// )

// // =======================
// // Payments Handlers
// func CreatePaymentHandler(c *gin.Context) {
// 	var req models.CreatePaymentRequest
// 	if err := c.ShouldBindJSON(&req); err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payload", "details": err.Error()})
// 		return
// 	}

// 	if req.UserID == uuid.Nil || req.PlanID == uuid.Nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "user_id and plan_id are required"})
// 		return
// 	}

// 	ctx := c.Request.Context()

// 	// Fetch plan details
// 	plan, err := db.Q.GetSubscriptionPlanByID(ctx, pgtype.UUID{Bytes: req.PlanID, Valid: true})
// 	if err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plan_id"})
// 		return
// 	}
// 	user, err := db.Q.GetUserByID(ctx, pgtype.UUID{Bytes: req.UserID, Valid: true})
// 	if err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user_id"})
// 		return
// 	}
// 	// Insert pending payment; transaction_id will be auto-generated by Postgres
// 	params := gen.CreatePaymentParams{
// 		UserID:         pgtype.UUID{Bytes: req.UserID, Valid: true},
// 		Email:          user.Email,
// 		PlanID:         pgtype.UUID{Bytes: req.PlanID, Valid: true},
// 		Amount:         float64(plan.Price),
// 		Currency:       "USD",
// 		PaymentGateway: pgtype.Text{String: "stripe", Valid: true},
// 	}

// 	payment, err := db.Q.CreatePayment(ctx, params)
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create payment", "details": err.Error()})
// 		return
// 	}

// 	log.Printf("Payment created: id=%s, transaction_id=%s, amount=%f %s",
// 		payment.ID, payment.TransactionID, payment.Amount, payment.Currency)

// 	// Initialize Stripe payment
// 	redirectURL, err := service.InitializeStripePayment(&payment)
// 	if err != nil {
// 		log.Println("Stripe session creation failed:", err)
// 		c.JSON(http.StatusInternalServerError, gin.H{
// 			"error":   "failed to initialize payment gateway",
// 			"details": err.Error(),
// 		})
// 		return
// 	}

// 	c.JSON(http.StatusOK, gin.H{
// 		"message":        "payment session created",
// 		"payment_id":     payment.ID,
// 		"transaction_id": payment.TransactionID,
// 		"redirect_url":   redirectURL,
// 	})
// }

// func GetPaymentHandler(c *gin.Context) {
// 	idStr := c.Param("id")
// 	id, err := uuid.Parse(idStr)
// 	if err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
// 		return
// 	}

// 	payment, err := db.Q.GetPaymentByID(c.Request.Context(), pgtype.UUID{Bytes: id, Valid: true})
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get payment", "details": err.Error()})
// 		return
// 	}

// 	c.JSON(http.StatusOK, gin.H{"payment": payment})
// }
// func ListAllPaymentsHandler(c *gin.Context) {
// 	// Pagination params (default: page 1, limit 20)
// 	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
// 	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
// 	if page < 1 {
// 		page = 1
// 	}
// 	if limit < 1 || limit > 100 {
// 		limit = 20
// 	}
// 	offset := (page - 1) * limit

// 	// Fetch payments
// 	payments, err := db.Q.GetAllPayments(c.Request.Context(), gen.GetAllPaymentsParams{Limit: int32(limit), Offset: int32(offset)})
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list payments"})
// 		return
// 	}

// 	response := make([]models.DashboardPaymentResponse, 0)

// 	for _, r := range payments {
// 		var refundStatus, refundReason string
// 		var requestedAt time.Time
// 		var processedAt *time.Time

// 		// --- 1. Fetch Refund (Safely) ---
// 		refunds, err := db.Q.GetRefundByPaymentID(c.Request.Context(), r.ID)
// 		if err != nil {
// 			// ✅ Check if the error is specifically "No Rows"
// 			if errors.Is(err, pgx.ErrNoRows) {
// 				// This is EXPECTED for most payments (not all payments have refunds).
// 				// We do nothing here, just let the variables stay empty.
// 			} else {
// 				// If it's a real database error (connection, etc), we fail.
// 				c.JSON(http.StatusInternalServerError, gin.H{"error": "something went wrong fetching refunds"})
// 				return
// 			}
// 		} else {
// 			// Data found, map it
// 			if refunds.PaymentID == r.ID {
// 				refundStatus = refunds.Status
// 				refundReason = refunds.Reason.String
// 				requestedAt = refunds.RequestedAt.Time
// 				if refunds.ProcessedAt.Valid {
// 					processedAt = &refunds.ProcessedAt.Time
// 				}
// 			}
// 		}

// 		// --- 2. Fetch User (Safely) ---
// 		username := "Unknown User"

// 		users, err := db.Q.GetUserByID(c.Request.Context(), r.UserID)
// 		if err != nil {
// 			// ✅ Check if user is missing (e.g., deleted account)
// 			if errors.Is(err, pgx.ErrNoRows) {
// 				// User not found, keep default "Unknown User"
// 			} else {
// 				c.JSON(http.StatusInternalServerError, gin.H{"error": "something went wrong fetching users"})
// 				return
// 			}
// 		} else {
// 			username = users.FirstName + " " + users.LastName
// 		}

// 		// --- 3. Handle Subscription UUID ---
// 		var subscriptionID *uuid.UUID
// 		if r.SubscriptionID.Valid {
// 			u, err := uuid.FromBytes(r.SubscriptionID.Bytes[:])
// 			if err == nil {
// 				subscriptionID = &u
// 			}
// 		}

// 		response = append(response, models.DashboardPaymentResponse{
// 			ID:             r.ID.Bytes,
// 			UserID:         r.UserID.Bytes,
// 			SubscriptionID: subscriptionID,
// 			Amount:         r.Amount,
// 			Currency:       r.Currency,
// 			TransactionID:  r.TransactionID.Bytes,
// 			PaymentGateway: r.PaymentGateway.String,
// 			Status:         r.Status,
// 			CreatedAt:      r.CreatedAt.Time,
// 			RefundStatus:   refundStatus,
// 			RefundReason:   refundReason,
// 			RequestedAt:    requestedAt,
// 			ProcessedAt:    processedAt,
// 			UserName:       username,
// 			UserEmail:      r.Email,
// 		})
// 	}

// 	totalPayments, err := db.Q.CountPayments(c.Request.Context())
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to count payments"})
// 		return
// 	}
// 	totalSales, err := db.Q.GetTotalSales(c.Request.Context())
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to calculate total sales"})
// 		return
// 	}
// 	c.JSON(http.StatusOK, gin.H{
// 		"payments": response,
// 		"metadata": gin.H{
// 			"total":      totalPayments,
// 			"page":       page,
// 			"limit":      limit,
// 			"totalSales": totalSales,
// 		},
// 	})
// }
// func SearchPaymentsPaginatedHandler(c *gin.Context) {
// 	// Pagination
// 	page := 1
// 	limit := 10

// 	if p := c.Query("page"); p != "" {
// 		if parsed, err := strconv.Atoi(p); err == nil && parsed > 0 {
// 			page = parsed
// 		}
// 	}

// 	if l := c.Query("limit"); l != "" {
// 		if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 {
// 			limit = parsed
// 		}
// 	}

// 	offset := (page - 1) * limit

// 	// Search query (partial email)
// 	query := strings.TrimSpace(c.Query("search"))
// 	if query == "" {
//         query = strings.TrimSpace(c.Query("email"))
//     }
// 	params := gen.SearchPaymentsByEmailWithPaginationParams{
// 		Column1: pgtype.Text{String: query, Valid: true},
// 		Limit:   int32(limit),
// 		Offset:  int32(offset),
// 	}
// 	// Execute search query
// 	rows, err := db.Q.SearchPaymentsByEmailWithPagination(c.Request.Context(), params)
// 	if err != nil {
// 		log.Printf("❌ Search error: %v", err)
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to fetch users"})
// 		return
// 	}

// 	// Count total matching users
// 	count, err := db.Q.CountPaymentsByEmail(c.Request.Context(), pgtype.Text{String: query, Valid: true})
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to count payments"})
// 		return
// 	}
// 	totalPages := int(math.Ceil(float64(count) / float64(limit)))

// 	// Map response
// 	var response []models.DashboardPaymentResponse
// 	for _, r := range rows {
// 		var refundStatus, refundReason string
// 		var requestedAt time.Time
// 		var processedAt *time.Time

// 		// --- 1. Fetch Refund (Safely) ---
// 		refunds, err := db.Q.GetRefundByPaymentID(c.Request.Context(), r.ID)
// 		if err != nil {
// 			// ✅ Check if the error is specifically "No Rows"
// 			if errors.Is(err, pgx.ErrNoRows) {
// 				// This is EXPECTED for most payments (not all payments have refunds).
// 				// We do nothing here, just let the variables stay empty.
// 			} else {
// 				// If it's a real database error (connection, etc), we fail.
// 				c.JSON(http.StatusInternalServerError, gin.H{"error": "something went wrong fetching refunds"})
// 				return
// 			}
// 		} else {
// 			// Data found, map it
// 			if refunds.PaymentID == r.ID {
// 				refundStatus = refunds.Status
// 				refundReason = refunds.Reason.String
// 				requestedAt = refunds.RequestedAt.Time
// 				if refunds.ProcessedAt.Valid {
// 					processedAt = &refunds.ProcessedAt.Time
// 				}
// 			}
// 		}

// 		// --- 2. Fetch User (Safely) ---
// 		username := "Unknown User"

// 		users, err := db.Q.GetUserByID(c.Request.Context(), r.UserID)
// 		if err != nil {
// 			// ✅ Check if user is missing (e.g., deleted account)
// 			if errors.Is(err, pgx.ErrNoRows) {
// 				// User not found, keep default "Unknown User"
// 			} else {
// 				c.JSON(http.StatusInternalServerError, gin.H{"error": "something went wrong fetching users"})
// 				return
// 			}
// 		} else {
// 			username = users.FirstName + " " + users.LastName
// 		}

// 		// --- 3. Handle Subscription UUID ---
// 		var subscriptionID *uuid.UUID
// 		if r.SubscriptionID.Valid {
// 			u, err := uuid.FromBytes(r.SubscriptionID.Bytes[:])
// 			if err == nil {
// 				subscriptionID = &u
// 			}
// 		}
// 		response = append(response, models.DashboardPaymentResponse{
// 			ID:             r.ID.Bytes,
// 			UserID:         r.UserID.Bytes,
// 			SubscriptionID: subscriptionID,
// 			Amount:         r.Amount,
// 			Currency:       r.Currency,
// 			TransactionID:  r.TransactionID.Bytes,
// 			PaymentGateway: r.PaymentGateway.String,
// 			Status:         r.Status,
// 			CreatedAt:      r.CreatedAt.Time,
// 			RefundStatus:   refundStatus,
// 			RefundReason:   refundReason,
// 			RequestedAt:    requestedAt,
// 			ProcessedAt:    processedAt,
// 			UserName:       username,
// 			UserEmail:      r.Email,
// 		})
// 	}

// 	c.JSON(http.StatusOK, gin.H{
// 		"payments": response,
// 		"metadata": gin.H{
// 			"total":      count,
// 			"page":       page,
// 			"limit":      limit,
// 			"totalPages": totalPages,
// 		},
// 	})
// }
// func UpdatePaymentStatusHandler(c *gin.Context) {
// 	idStr := c.Param("id")
// 	id, err := uuid.Parse(idStr)
// 	if err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
// 		return
// 	}

// 	var req struct {
// 		Status string `json:"status"`
// 	}
// 	if err := c.ShouldBindJSON(&req); err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload", "details": err.Error()})
// 		return
// 	}

// 	// Validate status
// 	validStatuses := map[string]bool{"paid": true, "failed": true, "pending": true}
// 	if !validStatuses[req.Status] {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid status value"})
// 		return
// 	}

// 	params := gen.UpdatePaymentStatusParams{
// 		ID:     pgtype.UUID{Bytes: id, Valid: true},
// 		Status: req.Status,
// 	}

// 	payment, err := db.Q.UpdatePaymentStatus(c.Request.Context(), params)
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update payment status", "details": err.Error()})
// 		return
// 	}

// 	c.JSON(http.StatusOK, gin.H{"payment": payment})
// }

// func DeletePaymentByIDHandler(c *gin.Context) {
// 	idStr := c.Param("id")
// 	id, err := uuid.Parse(idStr)
// 	if err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
// 		return
// 	}

// 	if err := db.Q.DeletePayment(c.Request.Context(), pgtype.UUID{Bytes: id, Valid: true}); err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete payment", "details": err.Error()})
// 		return
// 	}

// 	c.JSON(http.StatusOK, gin.H{"message": "payment deleted"})
// }
