// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_address.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUserAddresses = `-- name: CountUserAddresses :one
SELECT COUNT(*) FROM user_addresses
WHERE user_id = $1
`

func (q *Queries) CountUserAddresses(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserAddresses, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserAddress = `-- name: CreateUserAddress :one
INSERT INTO user_addresses (
    user_id,
    label,
    address_line1,
    address_line2,
    area,
    city,
    postal_code,
    latitude,
    longitude,
    is_default
) VALUES (
    $1, $2, $3, $5, $4,
    COALESCE($6, 'Dhaka'), $7, $8, $9,
    COALESCE($10, false)
) RETURNING id, user_id, label, address_line1, address_line2, area, city, postal_code, latitude, longitude, is_default, created_at, updated_at
`

type CreateUserAddressParams struct {
	UserID       pgtype.UUID    `json:"user_id"`
	Label        string         `json:"label"`
	AddressLine1 string         `json:"address_line1"`
	Area         string         `json:"area"`
	AddressLine2 pgtype.Text    `json:"address_line2"`
	City         interface{}    `json:"city"`
	PostalCode   pgtype.Text    `json:"postal_code"`
	Latitude     pgtype.Numeric `json:"latitude"`
	Longitude    pgtype.Numeric `json:"longitude"`
	IsDefault    interface{}    `json:"is_default"`
}

func (q *Queries) CreateUserAddress(ctx context.Context, arg CreateUserAddressParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, createUserAddress,
		arg.UserID,
		arg.Label,
		arg.AddressLine1,
		arg.Area,
		arg.AddressLine2,
		arg.City,
		arg.PostalCode,
		arg.Latitude,
		arg.Longitude,
		arg.IsDefault,
	)
	var i UserAddress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Label,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.PostalCode,
		&i.Latitude,
		&i.Longitude,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserAddress = `-- name: DeleteUserAddress :exec
DELETE FROM user_addresses WHERE id = $1
`

func (q *Queries) DeleteUserAddress(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserAddress, id)
	return err
}

const getUserAddressByID = `-- name: GetUserAddressByID :one
SELECT id, user_id, label, address_line1, address_line2, area, city, postal_code, latitude, longitude, is_default, created_at, updated_at FROM user_addresses WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserAddressByID(ctx context.Context, id pgtype.UUID) (UserAddress, error) {
	row := q.db.QueryRow(ctx, getUserAddressByID, id)
	var i UserAddress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Label,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.PostalCode,
		&i.Latitude,
		&i.Longitude,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUserAddresses = `-- name: ListUserAddresses :many
SELECT id, user_id, label, address_line1, address_line2, area, city, postal_code, latitude, longitude, is_default, created_at, updated_at FROM user_addresses 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserAddressesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListUserAddresses(ctx context.Context, arg ListUserAddressesParams) ([]UserAddress, error) {
	rows, err := q.db.Query(ctx, listUserAddresses, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAddress
	for rows.Next() {
		var i UserAddress
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Label,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.Area,
			&i.City,
			&i.PostalCode,
			&i.Latitude,
			&i.Longitude,
			&i.IsDefault,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUserAddresses = `-- name: SearchUserAddresses :many
SELECT id, user_id, label, address_line1, address_line2, area, city, postal_code, latitude, longitude, is_default, created_at, updated_at FROM user_addresses 
WHERE user_id = $1 AND (
    label ILIKE '%' || $2 || '%' OR
    address_line1 ILIKE '%' || $2 || '%' OR
    area ILIKE '%' || $2 || '%' OR
    city ILIKE '%' || $2 || '%'
)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchUserAddressesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchUserAddresses(ctx context.Context, arg SearchUserAddressesParams) ([]UserAddress, error) {
	rows, err := q.db.Query(ctx, searchUserAddresses,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAddress
	for rows.Next() {
		var i UserAddress
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Label,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.Area,
			&i.City,
			&i.PostalCode,
			&i.Latitude,
			&i.Longitude,
			&i.IsDefault,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultUserAddress = `-- name: SetDefaultUserAddress :exec
UPDATE user_addresses
SET is_default = false
WHERE user_id = $1 AND id != $2
`

type SetDefaultUserAddressParams struct {
	UserID pgtype.UUID `json:"user_id"`
	ID     pgtype.UUID `json:"id"`
}

func (q *Queries) SetDefaultUserAddress(ctx context.Context, arg SetDefaultUserAddressParams) error {
	_, err := q.db.Exec(ctx, setDefaultUserAddress, arg.UserID, arg.ID)
	return err
}

const updateUserAddress = `-- name: UpdateUserAddress :one
UPDATE user_addresses
SET
    label        = COALESCE($1, label),
    address_line1 = COALESCE($2, address_line1),
    address_line2 = COALESCE($3, address_line2),
    area         = COALESCE($4, area),
    city         = COALESCE($5, city),
    postal_code  = COALESCE($6, postal_code),
    latitude     = COALESCE($7, latitude),
    longitude    = COALESCE($8, longitude),
    is_default   = COALESCE($9, is_default),
    updated_at   = CURRENT_TIMESTAMP
WHERE id = $10
RETURNING id, user_id, label, address_line1, address_line2, area, city, postal_code, latitude, longitude, is_default, created_at, updated_at
`

type UpdateUserAddressParams struct {
	Label        pgtype.Text    `json:"label"`
	AddressLine1 pgtype.Text    `json:"address_line1"`
	AddressLine2 pgtype.Text    `json:"address_line2"`
	Area         pgtype.Text    `json:"area"`
	City         pgtype.Text    `json:"city"`
	PostalCode   pgtype.Text    `json:"postal_code"`
	Latitude     pgtype.Numeric `json:"latitude"`
	Longitude    pgtype.Numeric `json:"longitude"`
	IsDefault    pgtype.Bool    `json:"is_default"`
	ID           pgtype.UUID    `json:"id"`
}

func (q *Queries) UpdateUserAddress(ctx context.Context, arg UpdateUserAddressParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, updateUserAddress,
		arg.Label,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.Area,
		arg.City,
		arg.PostalCode,
		arg.Latitude,
		arg.Longitude,
		arg.IsDefault,
		arg.ID,
	)
	var i UserAddress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Label,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.PostalCode,
		&i.Latitude,
		&i.Longitude,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
