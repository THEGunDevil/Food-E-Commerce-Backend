// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdateAvailability = `-- name: BulkUpdateAvailability :exec
UPDATE menu_items 
SET 
    is_available = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE category_id = $1
`

type BulkUpdateAvailabilityParams struct {
	CategoryID  pgtype.UUID `json:"category_id"`
	IsAvailable pgtype.Bool `json:"is_available"`
}

func (q *Queries) BulkUpdateAvailability(ctx context.Context, arg BulkUpdateAvailabilityParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateAvailability, arg.CategoryID, arg.IsAvailable)
	return err
}

const countAvailableMenuItems = `-- name: CountAvailableMenuItems :one
SELECT COUNT(*) FROM menu_items 
WHERE is_available = true
`

func (q *Queries) CountAvailableMenuItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableMenuItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMenuItems = `-- name: CountMenuItems :one
SELECT COUNT(*) FROM menu_items
`

func (q *Queries) CountMenuItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMenuItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMenuItemsByCategory = `-- name: CountMenuItemsByCategory :one
SELECT COUNT(*) 
FROM menu_items
WHERE category_id = $1
`

func (q *Queries) CountMenuItemsByCategory(ctx context.Context, categoryID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMenuItemsByCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMenuItem = `-- name: CreateMenuItem :one
INSERT INTO menu_items (
    category_id,
    name,
    slug,
    description,
    price,
    discount_price,
    ingredients,
    tags,
    prep_time,
    spicy_level,
    is_vegetarian,
    is_special,
    is_available,
    stock_quantity,
    min_stock_alert,
    display_order
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14, $15, $16
)
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

type CreateMenuItemParams struct {
	CategoryID    pgtype.UUID    `json:"category_id"`
	Name          string         `json:"name"`
	Slug          string         `json:"slug"`
	Description   pgtype.Text    `json:"description"`
	Price         pgtype.Numeric `json:"price"`
	DiscountPrice pgtype.Numeric `json:"discount_price"`
	Ingredients   []string       `json:"ingredients"`
	Tags          []string       `json:"tags"`
	PrepTime      pgtype.Int4    `json:"prep_time"`
	SpicyLevel    pgtype.Int4    `json:"spicy_level"`
	IsVegetarian  pgtype.Bool    `json:"is_vegetarian"`
	IsSpecial     pgtype.Bool    `json:"is_special"`
	IsAvailable   pgtype.Bool    `json:"is_available"`
	StockQuantity pgtype.Int4    `json:"stock_quantity"`
	MinStockAlert pgtype.Int4    `json:"min_stock_alert"`
	DisplayOrder  pgtype.Int4    `json:"display_order"`
}

func (q *Queries) CreateMenuItem(ctx context.Context, arg CreateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, createMenuItem,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Price,
		arg.DiscountPrice,
		arg.Ingredients,
		arg.Tags,
		arg.PrepTime,
		arg.SpicyLevel,
		arg.IsVegetarian,
		arg.IsSpecial,
		arg.IsAvailable,
		arg.StockQuantity,
		arg.MinStockAlert,
		arg.DisplayOrder,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMenuItemImage = `-- name: CreateMenuItemImage :exec
INSERT INTO menu_item_images (
    menu_item_id,
    image_url,
    image_public_id,
    is_primary,
    display_order
)
VALUES ($1, $2, $3, $4, $5)
`

type CreateMenuItemImageParams struct {
	MenuItemID    pgtype.UUID `json:"menu_item_id"`
	ImageUrl      string      `json:"image_url"`
	ImagePublicID pgtype.Text `json:"image_public_id"`
	IsPrimary     pgtype.Bool `json:"is_primary"`
	DisplayOrder  pgtype.Int4 `json:"display_order"`
}

func (q *Queries) CreateMenuItemImage(ctx context.Context, arg CreateMenuItemImageParams) error {
	_, err := q.db.Exec(ctx, createMenuItemImage,
		arg.MenuItemID,
		arg.ImageUrl,
		arg.ImagePublicID,
		arg.IsPrimary,
		arg.DisplayOrder,
	)
	return err
}

const decrementStock = `-- name: DecrementStock :one
UPDATE menu_items 
SET 
    stock_quantity = stock_quantity - $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

type DecrementStockParams struct {
	ID            pgtype.UUID `json:"id"`
	StockQuantity pgtype.Int4 `json:"stock_quantity"`
}

func (q *Queries) DecrementStock(ctx context.Context, arg DecrementStockParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, decrementStock, arg.ID, arg.StockQuantity)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMenuItem = `-- name: DeleteMenuItem :exec
DELETE FROM menu_items 
WHERE id = $1
`

func (q *Queries) DeleteMenuItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMenuItem, id)
	return err
}

const deleteMenuItemImage = `-- name: DeleteMenuItemImage :exec
DELETE FROM menu_item_images
WHERE id = $1
`

func (q *Queries) DeleteMenuItemImage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMenuItemImage, id)
	return err
}

const filterMenuItemsBySpicyLevel = `-- name: FilterMenuItemsBySpicyLevel :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE 
    spicy_level = $1
    AND is_available = true
ORDER BY display_order, name 
LIMIT $2 OFFSET $3
`

type FilterMenuItemsBySpicyLevelParams struct {
	SpicyLevel pgtype.Int4 `json:"spicy_level"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) FilterMenuItemsBySpicyLevel(ctx context.Context, arg FilterMenuItemsBySpicyLevelParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, filterMenuItemsBySpicyLevel, arg.SpicyLevel, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterMenuItemsByTags = `-- name: FilterMenuItemsByTags :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE 
    tags @> $1::varchar(50)[]
    AND is_available = true
ORDER BY display_order, name 
LIMIT $2 OFFSET $3
`

type FilterMenuItemsByTagsParams struct {
	Column1 []string `json:"column_1"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

func (q *Queries) FilterMenuItemsByTags(ctx context.Context, arg FilterMenuItemsByTagsParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, filterMenuItemsByTags, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscountedMenuItems = `-- name: GetDiscountedMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE discount_price IS NOT NULL 
AND discount_price > 0
AND is_available = true
ORDER BY (price - discount_price) DESC
LIMIT $1 OFFSET $2
`

type GetDiscountedMenuItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetDiscountedMenuItems(ctx context.Context, arg GetDiscountedMenuItemsParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getDiscountedMenuItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockMenuItems = `-- name: GetLowStockMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE 
    stock_quantity > 0 
    AND stock_quantity <= min_stock_alert
    AND is_available = true
ORDER BY stock_quantity ASC
`

func (q *Queries) GetLowStockMenuItems(ctx context.Context) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getLowStockMenuItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMenuItem = `-- name: GetMenuItem :one
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMenuItem(ctx context.Context, id pgtype.UUID) (MenuItem, error) {
	row := q.db.QueryRow(ctx, getMenuItem, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMenuItemByID = `-- name: GetMenuItemByID :one
SELECT
    menu_items.id, menu_items.category_id, menu_items.name, menu_items.slug, menu_items.description, menu_items.price, menu_items.discount_price, menu_items.ingredients, menu_items.tags, menu_items.prep_time, menu_items.spicy_level, menu_items.is_vegetarian, menu_items.is_special, menu_items.is_available, menu_items.stock_quantity, menu_items.min_stock_alert, menu_items.total_orders, menu_items.average_rating, menu_items.display_order, menu_items.created_at, menu_items.updated_at,
    categories.name AS CategoryName
FROM menu_items
JOIN categories ON menu_items.category_id = categories.id
WHERE menu_items.id = $1
`

type GetMenuItemByIDRow struct {
	ID            pgtype.UUID      `json:"id"`
	CategoryID    pgtype.UUID      `json:"category_id"`
	Name          string           `json:"name"`
	Slug          string           `json:"slug"`
	Description   pgtype.Text      `json:"description"`
	Price         pgtype.Numeric   `json:"price"`
	DiscountPrice pgtype.Numeric   `json:"discount_price"`
	Ingredients   []string         `json:"ingredients"`
	Tags          []string         `json:"tags"`
	PrepTime      pgtype.Int4      `json:"prep_time"`
	SpicyLevel    pgtype.Int4      `json:"spicy_level"`
	IsVegetarian  pgtype.Bool      `json:"is_vegetarian"`
	IsSpecial     pgtype.Bool      `json:"is_special"`
	IsAvailable   pgtype.Bool      `json:"is_available"`
	StockQuantity pgtype.Int4      `json:"stock_quantity"`
	MinStockAlert pgtype.Int4      `json:"min_stock_alert"`
	TotalOrders   pgtype.Int4      `json:"total_orders"`
	AverageRating pgtype.Numeric   `json:"average_rating"`
	DisplayOrder  pgtype.Int4      `json:"display_order"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	Categoryname  string           `json:"categoryname"`
}

func (q *Queries) GetMenuItemByID(ctx context.Context, id pgtype.UUID) (GetMenuItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getMenuItemByID, id)
	var i GetMenuItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Categoryname,
	)
	return i, err
}

const getMenuItemBySlug = `-- name: GetMenuItemBySlug :one
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetMenuItemBySlug(ctx context.Context, slug string) (MenuItem, error) {
	row := q.db.QueryRow(ctx, getMenuItemBySlug, slug)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMenuItemImagesByMenuItemID = `-- name: GetMenuItemImagesByMenuItemID :many
SELECT id, menu_item_id, image_url, image_public_id, is_primary, display_order, created_at, updated_at
FROM menu_item_images
WHERE menu_item_id = $1
`

func (q *Queries) GetMenuItemImagesByMenuItemID(ctx context.Context, menuItemID pgtype.UUID) ([]MenuItemImage, error) {
	rows, err := q.db.Query(ctx, getMenuItemImagesByMenuItemID, menuItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItemImage
	for rows.Next() {
		var i MenuItemImage
		if err := rows.Scan(
			&i.ID,
			&i.MenuItemID,
			&i.ImageUrl,
			&i.ImagePublicID,
			&i.IsPrimary,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMenuItemStats = `-- name: GetMenuItemStats :one
SELECT 
    COUNT(*) as total_items,
    SUM(total_orders) as total_all_orders,
    AVG(price) as avg_price,
    MIN(price) as min_price,
    MAX(price) as max_price
FROM menu_items 
WHERE is_available = true
`

type GetMenuItemStatsRow struct {
	TotalItems     int64       `json:"total_items"`
	TotalAllOrders int64       `json:"total_all_orders"`
	AvgPrice       float64     `json:"avg_price"`
	MinPrice       interface{} `json:"min_price"`
	MaxPrice       interface{} `json:"max_price"`
}

func (q *Queries) GetMenuItemStats(ctx context.Context) (GetMenuItemStatsRow, error) {
	row := q.db.QueryRow(ctx, getMenuItemStats)
	var i GetMenuItemStatsRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalAllOrders,
		&i.AvgPrice,
		&i.MinPrice,
		&i.MaxPrice,
	)
	return i, err
}

const getMenuItemsWithCategory = `-- name: GetMenuItemsWithCategory :many
SELECT 
    m.id, m.category_id, m.name, m.slug, m.description, m.price, m.discount_price, m.ingredients, m.tags, m.prep_time, m.spicy_level, m.is_vegetarian, m.is_special, m.is_available, m.stock_quantity, m.min_stock_alert, m.total_orders, m.average_rating, m.display_order, m.created_at, m.updated_at,
    c.name as category_name,
    c.slug as category_slug
FROM menu_items m
LEFT JOIN categories c ON m.category_id = c.id
WHERE m.is_available = true
ORDER BY m.display_order, m.name
LIMIT $1 OFFSET $2
`

type GetMenuItemsWithCategoryParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMenuItemsWithCategoryRow struct {
	ID            pgtype.UUID      `json:"id"`
	CategoryID    pgtype.UUID      `json:"category_id"`
	Name          string           `json:"name"`
	Slug          string           `json:"slug"`
	Description   pgtype.Text      `json:"description"`
	Price         pgtype.Numeric   `json:"price"`
	DiscountPrice pgtype.Numeric   `json:"discount_price"`
	Ingredients   []string         `json:"ingredients"`
	Tags          []string         `json:"tags"`
	PrepTime      pgtype.Int4      `json:"prep_time"`
	SpicyLevel    pgtype.Int4      `json:"spicy_level"`
	IsVegetarian  pgtype.Bool      `json:"is_vegetarian"`
	IsSpecial     pgtype.Bool      `json:"is_special"`
	IsAvailable   pgtype.Bool      `json:"is_available"`
	StockQuantity pgtype.Int4      `json:"stock_quantity"`
	MinStockAlert pgtype.Int4      `json:"min_stock_alert"`
	TotalOrders   pgtype.Int4      `json:"total_orders"`
	AverageRating pgtype.Numeric   `json:"average_rating"`
	DisplayOrder  pgtype.Int4      `json:"display_order"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	CategoryName  pgtype.Text      `json:"category_name"`
	CategorySlug  pgtype.Text      `json:"category_slug"`
}

func (q *Queries) GetMenuItemsWithCategory(ctx context.Context, arg GetMenuItemsWithCategoryParams) ([]GetMenuItemsWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, getMenuItemsWithCategory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMenuItemsWithCategoryRow
	for rows.Next() {
		var i GetMenuItemsWithCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CategorySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutOfStockMenuItems = `-- name: GetOutOfStockMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE 
    stock_quantity = 0
    AND is_available = true
ORDER BY name
`

func (q *Queries) GetOutOfStockMenuItems(ctx context.Context) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getOutOfStockMenuItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularMenuItems = `-- name: GetPopularMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE is_available = true
ORDER BY total_orders DESC, average_rating DESC
LIMIT $1
`

func (q *Queries) GetPopularMenuItems(ctx context.Context, limit int32) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, getPopularMenuItems, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementMenuItemOrders = `-- name: IncrementMenuItemOrders :one
UPDATE menu_items 
SET 
    total_orders = total_orders + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

func (q *Queries) IncrementMenuItemOrders(ctx context.Context, id pgtype.UUID) (MenuItem, error) {
	row := q.db.QueryRow(ctx, incrementMenuItemOrders, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementStock = `-- name: IncrementStock :one
UPDATE menu_items 
SET 
    stock_quantity = stock_quantity + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

type IncrementStockParams struct {
	ID            pgtype.UUID `json:"id"`
	StockQuantity pgtype.Int4 `json:"stock_quantity"`
}

func (q *Queries) IncrementStock(ctx context.Context, arg IncrementStockParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, incrementStock, arg.ID, arg.StockQuantity)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAvailableMenuItems = `-- name: ListAvailableMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE is_available = true 
ORDER BY display_order, name 
LIMIT $1 OFFSET $2
`

type ListAvailableMenuItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAvailableMenuItems(ctx context.Context, arg ListAvailableMenuItemsParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listAvailableMenuItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItemImages = `-- name: ListMenuItemImages :many
SELECT id, menu_item_id, image_url, image_public_id, is_primary, display_order, created_at, updated_at
FROM menu_item_images
WHERE menu_item_id = $1
ORDER BY is_primary DESC, display_order ASC
`

func (q *Queries) ListMenuItemImages(ctx context.Context, menuItemID pgtype.UUID) ([]MenuItemImage, error) {
	rows, err := q.db.Query(ctx, listMenuItemImages, menuItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItemImage
	for rows.Next() {
		var i MenuItemImage
		if err := rows.Scan(
			&i.ID,
			&i.MenuItemID,
			&i.ImageUrl,
			&i.ImagePublicID,
			&i.IsPrimary,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItems = `-- name: ListMenuItems :many
SELECT
    menu_items.id, menu_items.category_id, menu_items.name, menu_items.slug, menu_items.description, menu_items.price, menu_items.discount_price, menu_items.ingredients, menu_items.tags, menu_items.prep_time, menu_items.spicy_level, menu_items.is_vegetarian, menu_items.is_special, menu_items.is_available, menu_items.stock_quantity, menu_items.min_stock_alert, menu_items.total_orders, menu_items.average_rating, menu_items.display_order, menu_items.created_at, menu_items.updated_at,
    categories.name AS CategoryName
FROM menu_items
JOIN categories ON menu_items.category_id = categories.id
ORDER BY
    menu_items.display_order,
    menu_items.name
LIMIT $1 OFFSET $2
`

type ListMenuItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListMenuItemsRow struct {
	ID            pgtype.UUID      `json:"id"`
	CategoryID    pgtype.UUID      `json:"category_id"`
	Name          string           `json:"name"`
	Slug          string           `json:"slug"`
	Description   pgtype.Text      `json:"description"`
	Price         pgtype.Numeric   `json:"price"`
	DiscountPrice pgtype.Numeric   `json:"discount_price"`
	Ingredients   []string         `json:"ingredients"`
	Tags          []string         `json:"tags"`
	PrepTime      pgtype.Int4      `json:"prep_time"`
	SpicyLevel    pgtype.Int4      `json:"spicy_level"`
	IsVegetarian  pgtype.Bool      `json:"is_vegetarian"`
	IsSpecial     pgtype.Bool      `json:"is_special"`
	IsAvailable   pgtype.Bool      `json:"is_available"`
	StockQuantity pgtype.Int4      `json:"stock_quantity"`
	MinStockAlert pgtype.Int4      `json:"min_stock_alert"`
	TotalOrders   pgtype.Int4      `json:"total_orders"`
	AverageRating pgtype.Numeric   `json:"average_rating"`
	DisplayOrder  pgtype.Int4      `json:"display_order"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	Categoryname  string           `json:"categoryname"`
}

func (q *Queries) ListMenuItems(ctx context.Context, arg ListMenuItemsParams) ([]ListMenuItemsRow, error) {
	rows, err := q.db.Query(ctx, listMenuItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMenuItemsRow
	for rows.Next() {
		var i ListMenuItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categoryname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItemsByCategory = `-- name: ListMenuItemsByCategory :many
SELECT
    menu_items.id, menu_items.category_id, menu_items.name, menu_items.slug, menu_items.description, menu_items.price, menu_items.discount_price, menu_items.ingredients, menu_items.tags, menu_items.prep_time, menu_items.spicy_level, menu_items.is_vegetarian, menu_items.is_special, menu_items.is_available, menu_items.stock_quantity, menu_items.min_stock_alert, menu_items.total_orders, menu_items.average_rating, menu_items.display_order, menu_items.created_at, menu_items.updated_at,
    categories.name AS CategoryName
FROM menu_items
JOIN categories ON menu_items.category_id = categories.id
WHERE category_id = $1 
AND is_available = true 
ORDER BY menu_items.display_order, menu_items.name 
LIMIT $2 OFFSET $3
`

type ListMenuItemsByCategoryParams struct {
	CategoryID pgtype.UUID `json:"category_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type ListMenuItemsByCategoryRow struct {
	ID            pgtype.UUID      `json:"id"`
	CategoryID    pgtype.UUID      `json:"category_id"`
	Name          string           `json:"name"`
	Slug          string           `json:"slug"`
	Description   pgtype.Text      `json:"description"`
	Price         pgtype.Numeric   `json:"price"`
	DiscountPrice pgtype.Numeric   `json:"discount_price"`
	Ingredients   []string         `json:"ingredients"`
	Tags          []string         `json:"tags"`
	PrepTime      pgtype.Int4      `json:"prep_time"`
	SpicyLevel    pgtype.Int4      `json:"spicy_level"`
	IsVegetarian  pgtype.Bool      `json:"is_vegetarian"`
	IsSpecial     pgtype.Bool      `json:"is_special"`
	IsAvailable   pgtype.Bool      `json:"is_available"`
	StockQuantity pgtype.Int4      `json:"stock_quantity"`
	MinStockAlert pgtype.Int4      `json:"min_stock_alert"`
	TotalOrders   pgtype.Int4      `json:"total_orders"`
	AverageRating pgtype.Numeric   `json:"average_rating"`
	DisplayOrder  pgtype.Int4      `json:"display_order"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	Categoryname  string           `json:"categoryname"`
}

func (q *Queries) ListMenuItemsByCategory(ctx context.Context, arg ListMenuItemsByCategoryParams) ([]ListMenuItemsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listMenuItemsByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMenuItemsByCategoryRow
	for rows.Next() {
		var i ListMenuItemsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Categoryname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpecialMenuItems = `-- name: ListSpecialMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE is_special = true 
AND is_available = true 
ORDER BY display_order, name 
LIMIT $1 OFFSET $2
`

type ListSpecialMenuItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSpecialMenuItems(ctx context.Context, arg ListSpecialMenuItemsParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listSpecialMenuItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVegetarianMenuItems = `-- name: ListVegetarianMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE is_vegetarian = true 
AND is_available = true 
ORDER BY display_order, name 
LIMIT $1 OFFSET $2
`

type ListVegetarianMenuItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListVegetarianMenuItems(ctx context.Context, arg ListVegetarianMenuItemsParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listVegetarianMenuItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMenuItems = `-- name: SearchMenuItems :many
SELECT id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at FROM menu_items 
WHERE 
    (name ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%')
    AND is_available = true
ORDER BY display_order, name 
LIMIT $2 OFFSET $3
`

type SearchMenuItemsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchMenuItems(ctx context.Context, arg SearchMenuItemsParams) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, searchMenuItems, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Price,
			&i.DiscountPrice,
			&i.Ingredients,
			&i.Tags,
			&i.PrepTime,
			&i.SpicyLevel,
			&i.IsVegetarian,
			&i.IsSpecial,
			&i.IsAvailable,
			&i.StockQuantity,
			&i.MinStockAlert,
			&i.TotalOrders,
			&i.AverageRating,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPrimaryMenuItemImage = `-- name: SetPrimaryMenuItemImage :exec
UPDATE menu_item_images
SET is_primary = CASE
    WHEN id = $2 THEN true
    ELSE false
END
WHERE menu_item_id = $1
`

type SetPrimaryMenuItemImageParams struct {
	MenuItemID pgtype.UUID `json:"menu_item_id"`
	ID         pgtype.UUID `json:"id"`
}

func (q *Queries) SetPrimaryMenuItemImage(ctx context.Context, arg SetPrimaryMenuItemImageParams) error {
	_, err := q.db.Exec(ctx, setPrimaryMenuItemImage, arg.MenuItemID, arg.ID)
	return err
}

const toggleMenuItemAvailability = `-- name: ToggleMenuItemAvailability :one
UPDATE menu_items 
SET 
    is_available = NOT is_available,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

func (q *Queries) ToggleMenuItemAvailability(ctx context.Context, id pgtype.UUID) (MenuItem, error) {
	row := q.db.QueryRow(ctx, toggleMenuItemAvailability, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDisplayOrder = `-- name: UpdateDisplayOrder :exec
UPDATE menu_items 
SET 
    display_order = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateDisplayOrderParams struct {
	ID           pgtype.UUID `json:"id"`
	DisplayOrder pgtype.Int4 `json:"display_order"`
}

func (q *Queries) UpdateDisplayOrder(ctx context.Context, arg UpdateDisplayOrderParams) error {
	_, err := q.db.Exec(ctx, updateDisplayOrder, arg.ID, arg.DisplayOrder)
	return err
}

const updateMenuItem = `-- name: UpdateMenuItem :one
UPDATE menu_items
SET
    category_id = COALESCE($2, category_id),
    name = COALESCE($3, name),
    slug = COALESCE($4, slug),
    description = COALESCE($5, description),
    price = COALESCE($6, price),
    discount_price = COALESCE($7, discount_price),
    ingredients = COALESCE($8, ingredients),
    tags = COALESCE($9, tags),
    prep_time = COALESCE($10, prep_time),
    spicy_level = COALESCE($11, spicy_level),
    is_vegetarian = COALESCE($12, is_vegetarian),
    is_special = COALESCE($13, is_special),
    is_available = COALESCE($14, is_available),
    stock_quantity = COALESCE($15, stock_quantity),
    min_stock_alert = COALESCE($16, min_stock_alert),
    display_order = COALESCE($17, display_order),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

type UpdateMenuItemParams struct {
	ID            pgtype.UUID    `json:"id"`
	CategoryID    pgtype.UUID    `json:"category_id"`
	Name          string         `json:"name"`
	Slug          string         `json:"slug"`
	Description   pgtype.Text    `json:"description"`
	Price         pgtype.Numeric `json:"price"`
	DiscountPrice pgtype.Numeric `json:"discount_price"`
	Ingredients   []string       `json:"ingredients"`
	Tags          []string       `json:"tags"`
	PrepTime      pgtype.Int4    `json:"prep_time"`
	SpicyLevel    pgtype.Int4    `json:"spicy_level"`
	IsVegetarian  pgtype.Bool    `json:"is_vegetarian"`
	IsSpecial     pgtype.Bool    `json:"is_special"`
	IsAvailable   pgtype.Bool    `json:"is_available"`
	StockQuantity pgtype.Int4    `json:"stock_quantity"`
	MinStockAlert pgtype.Int4    `json:"min_stock_alert"`
	DisplayOrder  pgtype.Int4    `json:"display_order"`
}

func (q *Queries) UpdateMenuItem(ctx context.Context, arg UpdateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItem,
		arg.ID,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Price,
		arg.DiscountPrice,
		arg.Ingredients,
		arg.Tags,
		arg.PrepTime,
		arg.SpicyLevel,
		arg.IsVegetarian,
		arg.IsSpecial,
		arg.IsAvailable,
		arg.StockQuantity,
		arg.MinStockAlert,
		arg.DisplayOrder,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMenuItemDynamic = `-- name: UpdateMenuItemDynamic :one
UPDATE menu_items 
SET 
    name = COALESCE($1, name),
    price = COALESCE($2, price),
    is_available = COALESCE($3, is_available),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

type UpdateMenuItemDynamicParams struct {
	Name        pgtype.Text    `json:"name"`
	Price       pgtype.Numeric `json:"price"`
	IsAvailable pgtype.Bool    `json:"is_available"`
	ID          pgtype.UUID    `json:"id"`
}

// This query uses jsonb to update dynamic fields
func (q *Queries) UpdateMenuItemDynamic(ctx context.Context, arg UpdateMenuItemDynamicParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItemDynamic,
		arg.Name,
		arg.Price,
		arg.IsAvailable,
		arg.ID,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMenuItemPartial = `-- name: UpdateMenuItemPartial :one
UPDATE menu_items 
SET 
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

func (q *Queries) UpdateMenuItemPartial(ctx context.Context, id pgtype.UUID) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItemPartial, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMenuItemRating = `-- name: UpdateMenuItemRating :one
UPDATE menu_items 
SET 
    average_rating = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

type UpdateMenuItemRatingParams struct {
	ID            pgtype.UUID    `json:"id"`
	AverageRating pgtype.Numeric `json:"average_rating"`
}

func (q *Queries) UpdateMenuItemRating(ctx context.Context, arg UpdateMenuItemRatingParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItemRating, arg.ID, arg.AverageRating)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMenuItemStock = `-- name: UpdateMenuItemStock :one
UPDATE menu_items 
SET 
    stock_quantity = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, category_id, name, slug, description, price, discount_price, ingredients, tags, prep_time, spicy_level, is_vegetarian, is_special, is_available, stock_quantity, min_stock_alert, total_orders, average_rating, display_order, created_at, updated_at
`

type UpdateMenuItemStockParams struct {
	ID            pgtype.UUID `json:"id"`
	StockQuantity pgtype.Int4 `json:"stock_quantity"`
}

func (q *Queries) UpdateMenuItemStock(ctx context.Context, arg UpdateMenuItemStockParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItemStock, arg.ID, arg.StockQuantity)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Price,
		&i.DiscountPrice,
		&i.Ingredients,
		&i.Tags,
		&i.PrepTime,
		&i.SpicyLevel,
		&i.IsVegetarian,
		&i.IsSpecial,
		&i.IsAvailable,
		&i.StockQuantity,
		&i.MinStockAlert,
		&i.TotalOrders,
		&i.AverageRating,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
